package pagination

import "github.com/fedotovmax/microservices-shop/customer-site/internal/components/button"
import "github.com/fedotovmax/microservices-shop/customer-site/pkg/utils"
import "github.com/fedotovmax/microservices-shop/customer-site/internal/components/icon"

import ()

type Props struct {
	ID         string
	Class      string
	Attributes templ.Attributes
}

type ContentProps struct {
	ID         string
	Class      string
	Attributes templ.Attributes
}

type ItemProps struct {
	ID         string
	Class      string
	Attributes templ.Attributes
}

type LinkProps struct {
	ID         string
	Class      string
	Attributes templ.Attributes
	Href       string
	IsActive   bool
	Disabled   bool
}

type PreviousProps struct {
	ID         string
	Class      string
	Attributes templ.Attributes
	Href       string
	Disabled   bool
	Label      string
}

type NextProps struct {
	ID         string
	Class      string
	Attributes templ.Attributes
	Href       string
	Disabled   bool
	Label      string
}

templ Pagination(props *Props) {
	{{ var p *Props }}
	if props != nil {
		{{ p = props }}
	} else {
		{{ p = &Props{} }}
	}
	<nav
		if p.ID != "" {
			id={ p.ID }
		}
		role="navigation"
		aria-label="pagination"
		class={ utils.TwMerge("flex flex-wrap justify-center", p.Class) }
		{ p.Attributes... }
	>
		{ children... }
	</nav>
}

templ Content(props *ContentProps) {
	{{ var p *ContentProps }}
	if props != nil {
		{{ p = props }}
	} else {
		{{ p = &ContentProps{} }}
	}
	<ul
		if p.ID != "" {
			id={ p.ID }
		}
		class="flex flex-row items-center gap-1"
		{ p.Attributes... }
	>
		{ children... }
	</ul>
}

templ Item(props *ItemProps) {
	{{ var p *ItemProps }}
	if props != nil {
		{{ p = props }}
	} else {
		{{ p = &ItemProps{} }}
	}
	<li
		if p.ID != "" {
			id={ p.ID }
		}
		{ p.Attributes... }
	>
		{ children... }
	</li>
}

templ Link(props *LinkProps) {
	{{ var p *LinkProps }}
	if props != nil {
		{{ p = props }}
	} else {
		{{ p = &LinkProps{} }}
	}
	if p.Disabled {
		@button.Button(&button.Props{
			ID:         p.ID,
			Disabled:   true,
			Size:       button.SizeIcon,
			Variant:    button.VariantGhost,
			Class:      p.Class,
			Attributes: p.Attributes,
		}) {
			{ children... }
		}
	} else {
		@button.Button(&button.Props{
			ID:         p.ID,
			Href:       p.Href,
			Size:       button.SizeIcon,
			Variant:    button.Variant(buttonVariant(p.IsActive)),
			Class:      p.Class,
			Attributes: p.Attributes,
		}) {
			{ children... }
		}
	}
}

templ Previous(props *PreviousProps) {
	{{ var p *PreviousProps }}
	if props != nil {
		{{ p = props }}
	} else {
		{{ p = &PreviousProps{} }}
	}
	@button.Button(&button.Props{
		ID:         p.ID,
		Href:       p.Href,
		Disabled:   p.Disabled,
		Variant:    button.VariantGhost,
		Class:      utils.TwMerge("gap-1", p.Class),
		Attributes: p.Attributes,
	}) {
		@icon.Icon(&icon.Props{
			Size: 16,
			Icon: icon.IconChevronLeft,
		})
		if p.Label != "" {
			<span>{ p.Label }</span>
		}
	}
}

templ Next(props *NextProps) {
	{{ var p *NextProps }}
	if props != nil {
		{{ p = props }}
	} else {
		{{ p = &NextProps{} }}
	}
	@button.Button(&button.Props{
		ID:         p.ID,
		Href:       p.Href,
		Disabled:   p.Disabled,
		Variant:    button.VariantGhost,
		Class:      utils.TwMerge("gap-1", p.Class),
		Attributes: p.Attributes,
	}) {
		if p.Label != "" {
			<span>{ p.Label }</span>
		}
		@icon.Icon(&icon.Props{
			Size: 16,
			Icon: icon.IconChevronRight,
		})
	}
}

templ Ellipsis() {
	@icon.Icon(&icon.Props{
		Size: 16,
		Icon: icon.IconEllipsis,
	})
}

func CreatePagination(currentPage, totalPages, maxVisible int) struct {
	CurrentPage int
	TotalPages  int
	Pages       []int
	HasPrevious bool
	HasNext     bool
} {
	if currentPage < 1 {
		currentPage = 1
	}
	if totalPages < 1 {
		totalPages = 1
	}
	if currentPage > totalPages {
		currentPage = totalPages
	}
	if maxVisible < 1 {
		maxVisible = 5
	}

	start, end := calculateVisibleRange(currentPage, totalPages, maxVisible)
	pages := make([]int, 0, end-start+1)
	for i := start; i <= end; i++ {
		pages = append(pages, i)
	}

	return struct {
		CurrentPage int
		TotalPages  int
		Pages       []int
		HasPrevious bool
		HasNext     bool
	}{
		CurrentPage: currentPage,
		TotalPages:  totalPages,
		Pages:       pages,
		HasPrevious: currentPage > 1,
		HasNext:     currentPage < totalPages,
	}
}

func calculateVisibleRange(currentPage, totalPages, maxVisible int) (int, int) {
	if totalPages <= maxVisible {
		return 1, totalPages
	}

	half := maxVisible / 2
	start := currentPage - half
	end := currentPage + half

	if start < 1 {
		end += (1 - start)
		start = 1
	}

	if end > totalPages {
		start -= (end - totalPages)
		if start < 1 {
			start = 1
		}
		end = totalPages
	}

	return start, end
}

func buttonVariant(isActive bool) button.Variant {
	if isActive {
		return button.VariantOutline
	}
	return button.VariantGhost
}
